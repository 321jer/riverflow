<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Utah River Flow Dashboard</title>
  <style>
    /* [Previous CSS remains exactly the same] */
  </style>
</head>
<body>
  <h1>Utah River Flow Dashboard</h1>
  <div class="grid" id="dashboard"></div>

  <script>
    // Configuration
    const SITES = [
      { name: "Colorado River @ Potash", id: "09185600" },
      { name: "Colorado River @ Cisco", id: "09180500" },
      { name: "Mill Creek @ Left Hand", id: "09183800" },
      { name: "Mill Creek @ Faux Falls", id: "09183600" },
      { name: "Mill Creek @ Wet Lands", id: "09185100" },
      { name: "Green River", id: "09315000" },
      { name: "Hobble Creek", id: "10153100" },
      { name: "Logan River", id: "10109000" },
      { name: "Middle Provo River", id: "10155200" }
    ];

    // USGS API Configuration
    const USGS_CONFIG = {
      iv: {
        baseUrl: "https://waterservices.usgs.gov/nwis/iv/",
        params: {
          format: "json",
          parameterCd: "00060,00010", // Discharge and temperature
          siteStatus: "all"
        }
      },
      dv: {
        baseUrl: "https://waterservices.usgs.gov/nwis/dv/",
        params: {
          format: "json",
          parameterCd: "00060",
          statCd: "00001,00002" // Min and max
        }
      },
      peak: {
        baseUrl: "https://waterdata.usgs.gov/nwis/peak",
        params: {
          format: "rdb",
          range_selection: "year_range"
        }
      }
    };

    async function fetchData() {
      const dashboard = document.getElementById('dashboard');
      dashboard.innerHTML = '';
      
      // Create all tiles with loading state
      SITES.forEach(site => {
        const tile = document.createElement('div');
        tile.className = 'tile loading';
        tile.id = `tile-${site.id}`;
        tile.innerHTML = `
          <h2>${site.name}</h2>
          <div class="metric highlight-flow">Loading current data...</div>
          <div class="metric"><strong>Temp:</strong> Loading...</div>
          <div class="metric"><strong>Updated:</strong> Loading...</div>
          <div class="metric"><strong>Quality:</strong> Loading...</div>
          <hr>
          <div class="metric-group">
            <div class="metric min"><strong>Min (Last Year):</strong> Loading...</div>
            <div class="metric max"><strong>Max (Last Year):</strong> Loading...</div>
          </div>
          <div class="metric-group">
            <div class="metric min"><strong>Min (Last Yr Mo):</strong> Loading...</div>
            <div class="metric max"><strong>Max (Last Yr Mo):</strong> Loading...</div>
          </div>
          <div class="metric-group">
            <div class="metric min"><strong>Min (5 Years):</strong> Loading...</div>
            <div class="metric max"><strong>Max (5 Years):</strong> Loading...</div>
          </div>
        `;
        dashboard.appendChild(tile);
      });

      // Fetch data for each site with error handling
      await Promise.allSettled(SITES.map(site => fetchSiteData(site)));
    }

    async function fetchSiteData(site) {
      try {
        // 1. Fetch current instantaneous values
        const ivData = await fetchInstantaneousValues(site.id);
        
        // 2. Fetch historical data
        const now = new Date();
        const lastYear = now.getFullYear() - 1;
        
        const [lastYearData, lastYearMonthData, fiveYearData] = await Promise.all([
          fetchDailyStats(site.id, `${lastYear}-01-01`, `${lastYear}-12-31`),
          fetchDailyStats(site.id, `${lastYear}-${now.getMonth()+1}-01`, `${lastYear}-${now.getMonth()+2}-01`),
          fetchFiveYearPeaks(site.id, now.getFullYear() - 5, lastYear)
        ]);
        
        // Update tile with all data
        updateTile(site, {
          current: ivData,
          lastYear: extractMinMax(lastYearData),
          lastYearMonth: extractMinMax(lastYearMonthData),
          fiveYear: fiveYearData
        });
        
      } catch (error) {
        console.error(`Error processing ${site.name}:`, error);
        updateTile(site, { error: true });
      }
    }

    async function fetchInstantaneousValues(siteId) {
      const url = new URL(USGS_CONFIG.iv.baseUrl);
      Object.entries({...USGS_CONFIG.iv.params, sites: siteId}).forEach(([key, value]) => {
        url.searchParams.append(key, value);
      });
      
      const response = await fetch(url);
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      
      const data = await response.json();
      if (!data.value?.timeSeries) throw new Error("Invalid data format");
      
      // Process flow data
      const flowSeries = data.value.timeSeries.find(s => 
        s.variable.variableCode[0].value === '00060');
      const flowValue = flowSeries?.values[0]?.value[0];
      
      // Process temperature data
      const tempSeries = data.value.timeSeries.find(s => 
        s.variable.variableCode[0].value === '00010');
      const tempValue = tempSeries?.values[0]?.value[0];
      
      return {
        flow: processFlowValue(flowValue?.value),
        temp: tempValue?.value ? (parseFloat(tempValue.value) * 9/5 + 32).toFixed(1) : null,
        timestamp: flowValue?.dateTime,
        quality: flowValue?.qualifiers?.join(', ') || 'Unknown'
      };
    }

    function processFlowValue(value) {
      if (!value) return null;
      const num = parseFloat(value);
      return (num >= 0) ? num : null; // Filter out error codes
    }

    async function fetchDailyStats(siteId, startDate, endDate) {
      const url = new URL(USGS_CONFIG.dv.baseUrl);
      Object.entries({
        ...USGS_CONFIG.dv.params,
        sites: siteId,
        startDT: startDate,
        endDT: endDate
      }).forEach(([key, value]) => {
        url.searchParams.append(key, value);
      });
      
      const response = await fetch(url);
      return await response.json();
    }

    async function fetchFiveYearPeaks(siteId, startYear, endYear) {
      const url = new URL(USGS_CONFIG.peak.baseUrl);
      Object.entries({
        ...USGS_CONFIG.peak.params,
        site_no: siteId,
        begin_date: `${startYear}-01-01`,
        end_date: `${endYear}-12-31`
      }).forEach(([key, value]) => {
        url.searchParams.append(key, value);
      });
      
      const response = await fetch(url);
      const text = await response.text();
      return parsePeakData(text);
    }

    function extractMinMax(data) {
      if (!data.value?.timeSeries?.[0]?.values) return { min: 'N/A', max: 'N/A' };
      
      const minValues = data.value.timeSeries[0].values.find(v => v.method.methodID === '00001');
      const maxValues = data.value.timeSeries[0].values.find(v => v.method.methodID === '00002');
      
      return {
        min: minValues?.value?.[0]?.value ? Math.round(parseFloat(minValues.value[0].value)) : 'N/A',
        max: maxValues?.value?.[0]?.value ? Math.round(parseFloat(maxValues.value[0].value)) : 'N/A'
      };
    }

    function parsePeakData(text) {
      const lines = text.split('\n').filter(line => !line.startsWith('#') && line.trim() !== '');
      if (lines.length < 2) return { min: 'N/A', max: 'N/A' };
      
      const headers = lines[0].split('\t');
      const data = lines[1].split('\t');
      
      const peakIndex = headers.indexOf('peak_va');
      const minIndex = headers.indexOf('min_va');
      
      return {
        min: (minIndex !== -1 && data[minIndex]) ? Math.round(parseFloat(data[minIndex])) : 'N/A',
        max: (peakIndex !== -1 && data[peakIndex]) ? Math.round(parseFloat(data[peakIndex])) : 'N/A'
      };
    }

    function updateTile(site, { current, lastYear, lastYearMonth, fiveYear, error }) {
      const tile = document.getElementById(`tile-${site.id}`);
      if (!tile) return;
      
      tile.classList.remove('loading');
      
      const updateElement = (selector, text) => {
        const el = tile.querySelector(selector);
        if (el) el.textContent = text;
      };
      
      if (error) {
        updateElement('.highlight-flow', 'Data unavailable');
        updateElement('.metric:nth-child(3)', 'Temp: N/A');
        updateElement('.metric:nth-child(4)', 'Updated: N/A');
        updateElement('.metric:nth-child(5)', 'Quality: Unknown');
        
        ['5', '6', '7'].forEach(n => {
          updateElement(`.metric-group:nth-child(${n}) .min`, `Min: Data unavailable`);
          updateElement(`.metric-group:nth-child(${n}) .max`, `Max: Data unavailable`);
        });
        return;
      }
      
      // Update current data
      if (current) {
        updateElement('.highlight-flow', current.flow ? `${current.flow.toLocaleString()} CFS` : 'N/A');
        updateElement('.metric:nth-child(3)', `Temp: ${current.temp || 'N/A'} Â°F`);
        
        if (current.timestamp) {
          try {
            const localTime = new Date(current.timestamp).toLocaleString('en-US', {
              timeZone: 'America/Denver',
              hour: 'numeric',
              minute: '2-digit',
              month: 'short',
              day: 'numeric'
            });
            updateElement('.metric:nth-child(4)', `Updated: ${localTime}`);
          } catch (e) {
            updateElement('.metric:nth-child(4)', `Updated: N/A`);
          }
        }
        
        updateElement('.metric:nth-child(5)', `Quality: ${current.quality}`);
      }
      
      // Update historical data
      if (lastYear) {
        updateElement('.metric-group:nth-child(6) .min', `Min (Last Year): ${lastYear.min.toLocaleString()} CFS`);
        updateElement('.metric-group:nth-child(6) .max', `Max (Last Year): ${lastYear.max.toLocaleString()} CFS`);
      }
      
      if (lastYearMonth) {
        updateElement('.metric-group:nth-child(7) .min', `Min (Last Yr Mo): ${lastYearMonth.min.toLocaleString()} CFS`);
        updateElement('.metric-group:nth-child(7) .max', `Max (Last Yr Mo): ${lastYearMonth.max.toLocaleString()} CFS`);
      }
      
      if (fiveYear) {
        updateElement('.metric-group:nth-child(8) .min', `Min (5 Years): ${fiveYear.min.toLocaleString()} CFS`);
        updateElement('.metric-group:nth-child(8) .max', `Max (5 Years): ${fiveYear.max.toLocaleString()} CFS`);
      }
    }

    // Initialize
    fetchData();
    setInterval(fetchData, 15 * 60 * 1000); // Refresh every 15 minutes
  </script>
</body>
</html>
