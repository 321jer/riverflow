<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Utah River Flow Dashboard</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #121212;
      color: #f4f4f4;
      margin: 0;
      padding: 1em;
    }
    h1 {
      text-align: center;
      margin-bottom: 1em;
      color: #ffffff;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1em;
    }
    .tile {
      background: #1e1e1e;
      border-radius: 10px;
      padding: 1em;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    .tile h2 {
      font-size: 1.2em;
      margin-bottom: 0.5em;
      color: #90caf9;
    }
    .metric {
      margin: 0.2em 0;
    }
    .highlight-flow {
      font-size: 1.6em;
      font-weight: bold;
      color: #4dd0e1;
    }
    .min, .max {
      color: #ffffff;
    }
    .temp-range {
      font-size: 0.9em;
    }
    .temp-min {
      color: #64b5f6;
    }
    .temp-max {
      color: #ef5350;
    }
    .metric-group {
      margin-top: 1.25em;
    }
    .loading {
      opacity: 0.6;
    }
    .error {
      color: #ef5350;
    }
  </style>
</head>
<body>
  <h1>Utah River Flow Dashboard</h1>
  <div class="grid" id="dashboard"></div>

  <script>
    // Configuration
    const SITES = [
      { name: "Colorado River @ Potash", id: "09185600" },
      { name: "Colorado River @ Cisco", id: "09180500" },
      { name: "Mill Creek @ Left Hand", id: "09183800" },
      { name: "Mill Creek @ Faux Falls", id: "09183600" },
      { name: "Mill Creek @ Wet Lands", id: "09185100" },
      { name: "Green River", id: "09315000" },
      { name: "Hobble Creek", id: "10153100" },
      { name: "Logan River", id: "10109000" },
      { name: "Middle Provo River", id: "10155200" }
    ];

    async function fetchData() {
      const dashboard = document.getElementById('dashboard');
      dashboard.innerHTML = '';
      
      // Create all tiles first
      SITES.forEach(site => {
        const tile = document.createElement('div');
        tile.className = 'tile loading';
        tile.id = `tile-${site.id}`;
        tile.innerHTML = `
          <h2>${site.name}</h2>
          <div class="metric highlight-flow">Loading...</div>
          <div class="metric"><strong>Temp:</strong> Loading...</div>
          <div class="metric"><strong>Updated:</strong> Loading...</div>
          <hr>
          <div class="metric-group">
            <div class="metric min"><strong>Min (Last Year):</strong> Loading...</div>
            <div class="metric max"><strong>Max (Last Year):</strong> Loading...</div>
          </div>
          <div class="metric-group">
            <div class="metric min"><strong>Min (Last Yr Mo):</strong> Loading...</div>
            <div class="metric max"><strong>Max (Last Yr Mo):</strong> Loading...</div>
          </div>
          <div class="metric-group">
            <div class="metric min"><strong>Min (5 Years):</strong> Loading...</div>
            <div class="metric max"><strong>Max (5 Years):</strong> Loading...</div>
          </div>
        `;
        dashboard.appendChild(tile);
      });

      // Fetch current data for all sites at once
      await fetchCurrentData();
      
      // Then fetch historical data for each site individually
      SITES.forEach(site => fetchHistoricalData(site));
    }

    async function fetchCurrentData() {
      try {
        const siteIds = SITES.map(site => site.id).join(',');
        const response = await fetch(`https://waterservices.usgs.gov/nwis/iv/?format=json&sites=${siteIds}&parameterCd=00060,00010&siteStatus=all`);
        
        if (!response.ok) throw new Error("Network response was not ok");
        
        const data = await response.json();
        
        if (!data.value || !data.value.timeSeries) {
          throw new Error("Invalid data format received");
        }
        
        // Process current data for all sites
        SITES.forEach(site => {
          const flowSeries = data.value.timeSeries.find(s => 
            s.sourceInfo.siteCode[0].value === site.id && 
            s.variable.variableCode[0].value === '00060');
          
          const tempSeries = data.value.timeSeries.find(s => 
            s.sourceInfo.siteCode[0].value === site.id && 
            s.variable.variableCode[0].value === '00010');
          
          let flowValue = flowSeries?.values[0]?.value[0]?.value;
          // Fix for -999999 values (USGS error code)
          if (flowValue && parseFloat(flowValue) < 0) flowValue = null;
          
          const tempValue = tempSeries?.values[0]?.value[0]?.value || null;
          const timestamp = flowSeries?.values[0]?.value[0]?.dateTime || '';
          
          updateTileCurrent(site, {
            flow: flowValue !== null ? parseFloat(flowValue).toLocaleString() : 'N/A',
            temp: tempValue !== null ? (parseFloat(tempValue) * 9/5 + 32).toFixed(1) : 'N/A',
            timestamp: timestamp
          });
        });
      } catch (error) {
        console.error("Error fetching current data:", error);
        SITES.forEach(site => {
          updateTileCurrent(site, {
            flow: 'N/A',
            temp: 'N/A',
            timestamp: 'Data unavailable'
          });
        });
      }
    }

    async function fetchHistoricalData(site) {
      try {
        const now = new Date();
        const currentYear = now.getFullYear();
        const currentMonth = now.getMonth();
        
        // Get last year's min/max
        const lastYear = await fetchMinMax(site.id, currentYear - 1);
        
        // Get same month last year min/max
        const lastYearMonth = await fetchMonthMinMax(site.id, currentYear - 1, currentMonth);
        
        // Get 5-year min/max (from annual peaks)
        const fiveYear = await fetchFiveYearPeaks(site.id, currentYear - 5, currentYear - 1);
        
        // Update the tile
        updateTileHistorical(site, {
          lastYear,
          lastYearMonth,
          fiveYear
        });
        
      } catch (error) {
        console.error(`Error fetching historical data for ${site.name}:`, error);
        updateTileHistorical(site, {
          error: true
        });
      }
    }

    async function fetchMinMax(siteId, year) {
      const url = `https://waterdata.usgs.gov/nwis/peak?site_no=${siteId}&range_selection=year_range&format=rdb&begin_date=${year}-01-01&end_date=${year}-12-31`;
      const response = await fetch(url);
      const text = await response.text();
      
      // Parse the RDB format
      const lines = text.split('\n').filter(line => !line.startsWith('#') && line.trim() !== '');
      if (lines.length < 2) return { min: 'N/A', max: 'N/A' };
      
      const headers = lines[0].split('\t');
      const data = lines[1].split('\t');
      
      const peakIndex = headers.indexOf('peak_va');
      const minIndex = headers.indexOf('min_va');
      
      return {
        min: minIndex !== -1 && data[minIndex] ? Math.round(parseFloat(data[minIndex])).toLocaleString() : 'N/A',
        max: peakIndex !== -1 && data[peakIndex] ? Math.round(parseFloat(data[peakIndex])).toLocaleString() : 'N/A'
      };
    }

    async function fetchMonthMinMax(siteId, year, month) {
      const monthStart = new Date(year, month, 1);
      const monthEnd = new Date(year, month + 1, 0);
      const url = `https://nwis.waterservices.usgs.gov/nwis/dv/?format=json&sites=${siteId}&startDT=${formatDate(monthStart)}&endDT=${formatDate(monthEnd)}&parameterCd=00060&statCd=00001,00002`;
      
      const response = await fetch(url);
      const data = await response.json();
      
      if (!data.value?.timeSeries?.[0]?.values) {
        return { min: 'N/A', max: 'N/A' };
      }
      
      const minValues = data.value.timeSeries[0].values.find(v => v.method.methodID === '00001');
      const maxValues = data.value.timeSeries[0].values.find(v => v.method.methodID === '00002');
      
      return {
        min: minValues?.value?.[0]?.value ? Math.round(parseFloat(minValues.value[0].value)).toLocaleString() : 'N/A',
        max: maxValues?.value?.[0]?.value ? Math.round(parseFloat(maxValues.value[0].value)).toLocaleString() : 'N/A'
      };
    }

    async function fetchFiveYearPeaks(siteId, startYear, endYear) {
      const years = Array.from({length: endYear - startYear + 1}, (_, i) => startYear + i);
      const peaks = await Promise.all(years.map(year => fetchMinMax(siteId, year)));
      
      const validPeaks = peaks.filter(p => p.max !== 'N/A').map(p => parseInt(p.max.replace(/,/g, '')));
      const validMins = peaks.filter(p => p.min !== 'N/A').map(p => parseInt(p.min.replace(/,/g, '')));
      
      return {
        min: validMins.length ? Math.min(...validMins).toLocaleString() : 'N/A',
        max: validPeaks.length ? Math.max(...validPeaks).toLocaleString() : 'N/A'
      };
    }

    function updateTileCurrent(site, { flow, temp, timestamp }) {
      const tile = document.getElementById(`tile-${site.id}`);
      if (!tile) return;
      
      const updateElement = (selector, text) => {
        const el = tile.querySelector(selector);
        if (el) el.textContent = text;
      };
      
      updateElement('.highlight-flow', `${flow} CFS`);
      updateElement('.metric:nth-child(3)', `Temp: ${temp} Â°F`);
      
      if (timestamp) {
        const localTime = new Date(timestamp).toLocaleString('en-US', { 
          timeZone: 'America/Denver',
          hour: 'numeric',
          minute: '2-digit',
          month: 'short',
          day: 'numeric'
        });
        updateElement('.metric:nth-child(4)', `Updated: ${localTime}`);
      }
      
      tile.classList.remove('loading');
    }

    function updateTileHistorical(site, { lastYear, lastYearMonth, fiveYear, error }) {
      const tile = document.getElementById(`tile-${site.id}`);
      if (!tile) return;
      
      const updateIfExists = (selector, text) => {
        const el = tile.querySelector(selector);
        if (el) el.textContent = text;
      };
      
      if (error) {
        updateIfExists('.metric-group:nth-child(5) .min', 'Min (Last Year): Data unavailable');
        updateIfExists('.metric-group:nth-child(5) .max', 'Max (Last Year): Data unavailable');
        updateIfExists('.metric-group:nth-child(6) .min', 'Min (Last Yr Mo): Data unavailable');
        updateIfExists('.metric-group:nth-child(6) .max', 'Max (Last Yr Mo): Data unavailable');
        updateIfExists('.metric-group:nth-child(7) .min', 'Min (5 Years): Data unavailable');
        updateIfExists('.metric-group:nth-child(7) .max', 'Max (5 Years): Data unavailable');
        return;
      }
      
      if (lastYear) {
        updateIfExists('.metric-group:nth-child(5) .min', `Min (Last Year): ${lastYear.min} CFS`);
        updateIfExists('.metric-group:nth-child(5) .max', `Max (Last Year): ${lastYear.max} CFS`);
      }
      
      if (lastYearMonth) {
        updateIfExists('.metric-group:nth-child(6) .min', `Min (Last Yr Mo): ${lastYearMonth.min} CFS`);
        updateIfExists('.metric-group:nth-child(6) .max', `Max (Last Yr Mo): ${lastYearMonth.max} CFS`);
      }
      
      if (fiveYear) {
        updateIfExists('.metric-group:nth-child(7) .min', `Min (5 Years): ${fiveYear.min} CFS`);
        updateIfExists('.metric-group:nth-child(7) .max', `Max (5 Years): ${fiveYear.max} CFS`);
      }
    }

    function formatDate(date) {
      return date.toISOString().split('T')[0];
    }

    // Initialize
    fetchData();
    setInterval(fetchData, 3600000); // Refresh every hour
  </script>
</body>
</html>
  </script>
</body>
</html>
